package polyeval;

import maxpower.kernel.KernelBinaryOp.Add;
import maxpower.utils.TreeReduce;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class VecMultiDenseRealKernel extends Kernel {

    static final DFEType FLOAT = dfeFloat(8, 24);

    static final DFEType UINT_32 = dfeUInt(32);

    static final DFEType UINT_63 = dfeUInt(63);

    VecMultiDenseRealKernel(KernelParameters parameters, int latency, int maxPolynomialLength, int tileSize) {
        super(parameters);

        DFEVectorType<DFEVar> resultType = new DFEVectorType<DFEVar>(FLOAT, tileSize);
        DFEFix addressType = dfeUInt(MathUtils.bitsToAddress(maxPolynomialLength));
        DFEVar n = io.scalarInput("n", UINT_32);
        DFEVar m = io.scalarInput("m", UINT_32);
        DFEVar tickCount = control.count.simpleCounter(32);


        DFEVar readAndWriteKs = (tickCount < n);
        CounterChain polynomialFragmentChain = control.count.makeCounterChain(~readAndWriteKs);
        DFEVar i = polynomialFragmentChain.addCounter(n / tileSize, 1);
        polynomialFragmentChain.addCounter(latency, 1);

        CounterChain kChain = control.count.makeCounterChain();
        DFEVar kCounter = kChain.addCounter(n, tileSize);
        kChain.addCounter(latency, 1);

        DFEVar readXFromStream = i === 0 & ~readAndWriteKs;
        Counter xCounter = control.count.makeCounter(control.count.makeParams(32)
        			.withEnable(readXFromStream)
        			.withWrapMode(WrapMode.STOP_AT_MAX));

        DFEVar xIn = io.input("xs", FLOAT, readXFromStream & xCounter.getCount() < m);
        DFEVar kIn = io.input("coefficients", FLOAT, readAndWriteKs);
    	Memory<DFEVar> kBuf = mem.alloc(FLOAT, maxPolynomialLength);
    	kBuf.write(tickCount.cast(addressType), kIn, readAndWriteKs);
    	// kBuf.mapToCPU("mem");

    	DFEVar initLoop = (i === 0);
    	DFEVar loopX = FLOAT.newInstance(this);
        DFEVar currentX = initLoop ? xIn : loopX;
    	DFEVector<DFEVar> result = resultType.newInstance(this);
    	DFEVector<DFEVar> previousResult = initLoop ? constant.vect(tileSize, FLOAT, 0.0) : result;
        DFEVar[] summands = new DFEVar[tileSize];
        DFEVar[] pows = getNextPows(tileSize, currentX, kCounter, initLoop);
        for (int t = 0; t < tileSize; t++) {
        	DFEVar address = (kCounter + t).cast(addressType);
        	DFEVar k = kBuf.read(address);
        	summands[t] = previousResult[t] + k * pows[t];
        	// debug.simPrintf("kIndex: %f, k: %f, x: %f, %f + %f * %f = %f\n", (kCounter + t), k, currentX, previousResult[t], k, pows[t], summands[t]);
        }
    	loopX <== stream.offset(currentX, -latency);
    	result <== stream.offset(DFEVectorType.newInstance(summands), -latency);

    	// kIn.simWatch("kIn");
        // Output
        io.output("result", TreeReduce.reduce(new Add<DFEVar>(), summands), FLOAT, ~readAndWriteKs & i >= ((n / tileSize) - 1));
    }

    private DFEVar[] getNextPows(int tileSize, DFEVar x, DFEVar k, DFEVar initLoop) {
    	DFEVar[] pows = new DFEVar[tileSize];
    	DFEVar pow = initLoop ? constant.var(FLOAT, 1.0) : powXY(x, k);
    	pows[0] = pow;
    	for (int i = 1; i < tileSize; i++) {
    		pows[i] = x * pows[i - 1];
    	}
    	return pows;
    }


    private DFEVar powXY(DFEVar x, DFEVar exp) {
        DFEVar xTemp = 1.0 * x;
        DFEVar powX = constant.var(FLOAT, 1.0);
        // Calculate max exponent of 2^10 = 1024,
        // this means we can do x^1024 at max
        for (int i = 0; i < 10; ++i) {
            powX = (exp.slice(0) === 1) ? powX * xTemp : powX;
            int newSize = UINT_32.getTotalBits() - i - 1;
            exp = exp.slice(1, newSize);
            xTemp = xTemp * xTemp;
        }
        return powX;
    }
}
