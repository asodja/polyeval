package polyeval;

import maxpower.kernel.KernelBinaryOp.Add;
import maxpower.utils.TreeReduce;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.Optimization.PipelinedOps;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class VecMultiDenseRealKernel extends Kernel {

    static final DFEType FLOAT = dfeFloat(8, 24);

    static final DFEType UINT_32 = dfeUInt(32);

    static final DFEType UINT_63 = dfeUInt(63);

	VecMultiDenseRealKernel(KernelParameters parameters,
			int latency,
			int maxPolynomialLength,
			int tileSize,
			int xsPerTick) {
        super(parameters);

        DFEVectorType<DFEVar> vecType = new DFEVectorType<DFEVar>(FLOAT, xsPerTick);
        DFEVectorType<DFEVector<DFEVar>> resultType = new DFEVectorType<DFEVector<DFEVar>>(vecType, tileSize);
        DFEFix addressType = dfeUInt(MathUtils.bitsToAddress(maxPolynomialLength));
        DFEVar n = io.scalarInput("n", UINT_32);
        DFEVar m = io.scalarInput("m", UINT_32);
        DFEVar tickCount = control.count.simpleCounter(32);

        DFEVar readAndWriteKs = (tickCount < n);

        CounterChain kChain = control.count.makeCounterChain(~readAndWriteKs);
        DFEVar kCounter = kChain.addCounter(n, tileSize);
        kChain.addCounter(latency, 1);

        DFEVar readXFromStream = kCounter === 0 & ~readAndWriteKs;
        Counter xCounter = control.count.makeCounter(control.count.makeParams(32)
        			.withEnable(readXFromStream)
        			.withWrapMode(WrapMode.STOP_AT_MAX));

        DFEVector<DFEVar> xIn = io.input("xs", vecType, readXFromStream & xCounter.getCount() < m / xsPerTick);
        DFEVar kIn = io.input("coefficients", FLOAT, readAndWriteKs);
    	Memory<DFEVar> kBuf = mem.alloc(FLOAT, maxPolynomialLength);
    	kBuf.write(tickCount.cast(addressType), kIn, readAndWriteKs);

    	DFEVar initLoop = (kCounter === 0);
    	DFEVector<DFEVar> loopX = vecType.newInstance(this);
    	DFEVector<DFEVar> loopPows = vecType.newInstance(this);
    	DFEVector<DFEVar> currentX = initLoop ? xIn : loopX;
    	DFEVector<DFEVector<DFEVar>> result = resultType.newInstance(this);
    	@SuppressWarnings("unchecked")
    	DFEVector<DFEVar>[] summands = new DFEVector[tileSize];
        DFEVector<DFEVar>[] pows = getNextPows(tileSize, xsPerTick, currentX, kCounter, initLoop, loopPows);
        for (int t = 0; t < tileSize; t++) {
        	DFEVar address = (kCounter + t).cast(addressType);
        	DFEVar k = kBuf.read(address);
        	DFEVector<DFEVar> previousResult = initLoop ? constant.vect(xsPerTick, FLOAT, 0.0) : result.get(t);
        	summands[t] = previousResult + k * pows[t];
        	// debug.simPrintf("readW: %d, tickCount: %f, kIndex: %f, xIn: %f, currentX: %f, %f + %f * %f = %f\n", readAndWriteKs, tickCount, (kCounter + t), xIn, currentX, previousResult[t], k, pows[t], summands[t]);
        }
        loopPows <== stream.offset(pows[tileSize - 1], -latency);
    	loopX <== stream.offset(currentX, -latency);
    	result <== stream.offset(DFEVectorType.newInstance(summands), -latency);

    	// kIn.simWatch("kIn");
    	// xIn.simWatch("xin");
    	// tickCount.simWatch("ticks");
        // Output

        io.output("result", TreeReduce.reduce(new Add<DFEVector<DFEVar>>(), summands), vecType, ~readAndWriteKs & kCounter >= (n - tileSize));
    }

    private DFEVector<DFEVar>[] getNextPows(
    		int tileSize,
    		int xsPerTick,
    		DFEVector<DFEVar> x,
    		DFEVar k,
    		DFEVar initLoop,
    		DFEVector<DFEVar> loopPows) {
    	@SuppressWarnings("unchecked")
		DFEVector<DFEVar>[] pows = new DFEVector[tileSize];
    	DFEVector<DFEVar> pow = initLoop ? constant.vect(xsPerTick, FLOAT, 1.0) : loopPows;
    	pows[0] = initLoop ? pow : loopPows * x;
    	optimization.pushPipeliningFactor(0, PipelinedOps.FLOAT_MUL);
    	for (int i = 1; i < tileSize; i++) {
    		pows[i] = x * pows[i - 1];
    	}
    	optimization.popPipeliningFactor(PipelinedOps.FLOAT_MUL);
    	return pows;
    }

}
