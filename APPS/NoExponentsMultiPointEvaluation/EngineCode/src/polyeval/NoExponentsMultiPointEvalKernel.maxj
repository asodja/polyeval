package polyeval;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class NoExponentsMultiPointEvalKernel extends PolyKernel {

    static final DFEType FLOAT = dfeFloat(8, 24);

    static final int FRAGMENT_SIZE = 20;

    static final int MAX_POLYNOMIAL_LENGTH = 1024;

    static final int ADDRESS_BITS = MathUtils.bitsToAddress(MAX_POLYNOMIAL_LENGTH);

    NoExponentsMultiPointEvalKernel(KernelParameters parameters) {
        super(parameters);

        // Input
        DFEVar polynomialLength = io.scalarInput("polynomialLength", dfeUInt(32));
        DFEVar nPoints = io.scalarInput("nPoints", dfeUInt(32));

        CounterChain chain = control.count.makeCounterChain();
        DFEVar fragmentIndex = chain.addCounter(nPoints / FRAGMENT_SIZE, 1);
        DFEVar polynomialIndex = chain.addCounter(polynomialLength, 1);
        DFEVar pointIndex = chain.addCounter(FRAGMENT_SIZE, 1);

        DFEVar constant = io.input("constants", dfeFloat(8, 24), fragmentIndex === 0 & pointIndex === 0);
        DFEVar point = io.input("points", dfeFloat(8, 24), polynomialIndex === 0);
        Memory<DFEVar> memory = mem.alloc(FLOAT, MAX_POLYNOMIAL_LENGTH);
        memory.write(polynomialIndex.cast(dfeUInt(ADDRESS_BITS)), constant, fragmentIndex === 0 & pointIndex === 0);
        DFEVar constantValue = (fragmentIndex === 0)
        		? constant
        		: memory.read(polynomialIndex.cast(dfeUInt(ADDRESS_BITS)));

        // Loop
        DFEVar cyclePoint = FLOAT.newInstance(this);
        DFEVar result = FLOAT.newInstance(this);
        DFEVar pointValue = (polynomialIndex === 0) ? point : cyclePoint;
        DFEVar multiply = (polynomialIndex === 0)
        		? (pointValue * constantValue)
        		: (pointValue * constantValue + result);

        result <== stream.offset(multiply, -FRAGMENT_SIZE);
        cyclePoint <== stream.offset(pointValue, -FRAGMENT_SIZE);

        polynomialIndex.simWatch("polynomialIndex");
        pointIndex.simWatch("pointIndex");
        point.simWatch("point");
        cyclePoint.simWatch("cyclePoint");
        multiply.simWatch("multiply");
        result.simWatch("result");

        // Output
        io.output("result", multiply, dfeFloat(8, 24), polynomialIndex === polynomialLength - 1);
    }

    @Override
    public EngineInterface getEngineInterface() {
        EngineInterface ei = new EngineInterface();

        InterfaceParam polynomialLength = ei.addParam("polynomialLength", CPUTypes.UINT32);
        InterfaceParam nPoints = ei.addParam("nPoints", CPUTypes.UINT32);
        ei.setScalar(getName(), "polynomialLength", polynomialLength);
        ei.setScalar(getName(), "nPoints", nPoints);
        ei.setStream("constants", CPUTypes.FLOAT, polynomialLength * CPUTypes.FLOAT.sizeInBytes());
        ei.setStream("points", CPUTypes.FLOAT, nPoints * CPUTypes.FLOAT.sizeInBytes());
        ei.setStream("result", CPUTypes.FLOAT, nPoints * CPUTypes.FLOAT.sizeInBytes());

        ei.setTicks(getName(), polynomialLength * nPoints);
        return ei;
    }
}
