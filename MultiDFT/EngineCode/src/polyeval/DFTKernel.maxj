package polyeval;

import java.util.ArrayList;
import java.util.List;

import maxpower.kernel.arithmetic.FloatingPointMultiAdder;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class DFTKernel extends Kernel {

    static final DFEType FLOAT = dfeFloat(8, 24);

    static final DFEType UINT_32 = dfeUInt(32);

    static final DFEType UINT_63 = dfeUInt(63);

	DFTKernel(KernelParameters parameters,
			int latency,
			int maxPolynomialLength,
			int tileSize,
			int xsPerTick) {
        super(parameters);
    	DFEType addrType = dfeUInt(MathUtils.bitsToAddress(maxPolynomialLength * 2));

        // n - size of DFT
        DFEVar n = io.scalarInput("n", UINT_32);
        // m - number of DFTs
        DFEVar m = io.scalarInput("m", UINT_32);
        DFEVar nPoints = n * m;
        DFEVar tickCount = control.count.simpleCounter(63);
        DFEVar initStream = tickCount < n.cast(UINT_63);

        // Main loop counter, first read n xs and do nothing
        // Number of iterations per one in dynamic loop
        DFEVar iterations = KernelMath.max(constant.var(1), n / tileSize);
        CounterChain cc = control.count.makeCounterChain(~initStream);
        DFEVar readParity = cc.addCounter(2, 1);
        DFEVar i = cc.addCounter(iterations, 1);
        cc.addCounter(latency, 1).setReportOnUnused(false);

        // Start reading only when
        // we evaluate first iteration
        DFEVar readXs = (i === 0);
        // Counter to control how many xs we have read
        Counter xCounter = getXCounter(nPoints, readXs);
        // Parity since we use two sized buffer
        CounterChain parityChain = control.count.makeCounterChain(readXs);
        DFEVar parity = parityChain.addCounter(2, 1);
        DFEVar xIndex = parityChain.addCounter(n, 1);
        // Since Main loop starts when first n xs are read,
        // read and write addresses are switched
        DFEVar readAddress = (readParity === 0) ? constant.zero(UINT_32) : constant.var(UINT_32, maxPolynomialLength);
        DFEVar writeAddress = (parity === 0) ? constant.zero(UINT_32) : constant.var(UINT_32, maxPolynomialLength);

        // Read and write xs into mem until all are read
        DFEVar xIn = io.input("xs", FLOAT, readXs & xCounter.getCount() < nPoints);
    	Memory<DFEVar> xBuf = mem.alloc(FLOAT, maxPolynomialLength * 2);
    	xBuf.write((writeAddress + xIndex).cast(addrType), xIn, readXs & xCounter.getCount() < nPoints);

    	DFEVar initLoop = (i === 0);
    	DFEVar memReadOffset = (readAddress + i * tileSize);
    	DFEVar partialSum = FLOAT.newInstance(this);
    	DFEVar previousSum = initLoop ? constant.var(FLOAT, 0.0) : partialSum;
    	List<DFEVar> summands = new ArrayList<DFEVar>();
        for (int t = 0; t < tileSize; t++) {
        	DFEVar address = (memReadOffset + t);
        	DFEVar x = xBuf.read(address.cast(addrType));
        	summands.add(x); // * e
        	if (t == 0) {
        		debug.simPrintf("tick: %d, address: %d, x: %f\n", tickCount, address, x);
        	}
        }
        DFEVar sum = FloatingPointMultiAdder.add(summands) + previousSum;
        partialSum <== stream.offset(sum, -latency);


        // debug.simPrintf("tick: %d, i: %d\n", tickCount, i);
        sum.simWatch("sum");
        i.simWatch("i");
        initStream.simWatch("initStream");
        readParity.simWatch("readParity");
    	// debug.simPrintf("readXs: %f, xCounter: %d, nPoints: %d\n", readXs, xCounter.getCount(), nPoints);

        // Output
        io.output("result", sum, FLOAT, i === iterations - 1);
    }

	private Counter getXCounter(DFEVar nPoints, DFEVar enable) {
        return control.count.makeCounter(control.count.makeParams(32)
        		.withMax(nPoints)
    			.withEnable(enable)
    			.withWrapMode(WrapMode.STOP_AT_MAX));
	}


}
