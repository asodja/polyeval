package polyeval;

import java.util.ArrayList;
import java.util.List;

import maxpower.kernel.arithmetic.FloatingPointMultiAdder;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class DFTKernel extends Kernel {

    static final DFEType FLOAT = dfeFloat(8, 24);

    static final DFEType UINT_32 = dfeUInt(32);

    static final DFEType UINT_63 = dfeUInt(63);

	DFTKernel(KernelParameters parameters,
			int latency,
			int maxPolynomialLength,
			int tileSize,
			int xsPerTick) {
        super(parameters);
    	DFEType addrType = dfeUInt(MathUtils.bitsToAddress(maxPolynomialLength * 2));

        // n - size of DFT
        DFEVar n = io.scalarInput("n", UINT_32);
        // m - number of DFTs
        DFEVar m = io.scalarInput("m", UINT_32);
        DFEVar nPoints = n * m;
        DFEVar tickCount = control.count.simpleCounter(63);
        DFEVar initStream = tickCount < n.cast(UINT_63);

        // Main loop counter, first read n xs and do nothing
        // Number of iterations per one in dynamic loop
        optimization.pushRoundingMode(RoundingMode.TRUNCATE);
        DFEVar js = (n - 1 + latency) / latency;
        DFEVar is = (n - 1 + tileSize) / tileSize;
        optimization.popRoundingMode();
        is.simWatch("iss");
        CounterChain cc = control.count.makeCounterChain(~initStream);
        DFEVar parity = cc.addCounter(2, 1);
        DFEVar j = cc.addCounter(js, 1); // current latency number xs
        DFEVar i = cc.addCounter(is, 1); // current tileSize xs for current latency tick
        DFEVar l = cc.addCounter(latency, 1); // currently latency tick

        // Start reading only when
        // we evaluate first iteration
        DFEVar subtick = initStream
        		? tickCount.cast(UINT_32)
        		: j.cast(UINT_32) * latency + l.cast(UINT_32);
        DFEVar readXs = (subtick < n);
        // Counter to control how many xs we have read
        Counter xCounter = getXCounter(nPoints, readXs);
        // Since Main loop starts when first n xs are read,
        // read and write addresses are switched
        DFEVar readAddress = (parity === 0) ? constant.zero(UINT_32) : constant.var(UINT_32, maxPolynomialLength);
        DFEVar writeAddress = (initStream | parity === 1) ? constant.zero(UINT_32) : constant.var(UINT_32, maxPolynomialLength);

        // Read and write xs into mem until all are read
        DFEVar xIn = io.input("xs", FLOAT, readXs & xCounter.getCount() < nPoints);
    	Memory<DFEVar> xBuf = mem.alloc(FLOAT, maxPolynomialLength * 2);
    	xBuf.write((writeAddress + subtick).cast(addrType), xIn, readXs & xCounter.getCount() < nPoints);

    	DFEVar initLoop = (i === 0);
    	DFEVar memReadOffset = (readAddress + i * tileSize);
    	DFEVar partialSum = FLOAT.newInstance(this);
    	DFEVar previousSum = initLoop ? constant.var(FLOAT, 0.0) : partialSum;
    	List<DFEVar> summands = new ArrayList<DFEVar>();
        for (int t = 0; t < tileSize; t++) {
        	DFEVar address = (memReadOffset + t);
        	DFEVar x = xBuf.read(address.cast(addrType));
        	summands.add(x); // * e
    		debug.simPrintf("tick: %d, address: %d, x: %f\n", tickCount, address, x);
        }
        DFEVar sum = FloatingPointMultiAdder.add(summands) + previousSum;
        partialSum <== stream.offset(sum, -latency);


        // debug.simPrintf("tick: %d, i: %d\n", tickCount, i);
        sum.simWatch("sum");
        i.simWatch("i");
        is.simWatch("ssss");
        initStream.simWatch("initStream");
        parity.simWatch("parity");
        subtick.simWatch("subtick");
        xIn.simWatch("xIn");
    	// debug.simPrintf("readXs: %f, xCounter: %d, nPoints: %d\n", readXs, xCounter.getCount(), nPoints);

        // Output
        DFEVar out = ~initStream & (i === is - 1) & (subtick < n);
        io.output("result", sum, FLOAT, out);
    }

	private Counter getXCounter(DFEVar nPoints, DFEVar enable) {
        return control.count.makeCounter(control.count.makeParams(32)
        		.withMax(nPoints)
    			.withEnable(enable)
    			.withWrapMode(WrapMode.STOP_AT_MAX));
	}

}
